DEFINE_ACES_PARAM(IS_PARAMETRIC_ACES_TRANSFORM : 0)

#define totalTableSize 362
#define tableSize 360
#define baseIndex 1

#define cuspCornerCount 6
#define totalCornerCount 8
#define max_sorted_corners 12
#define reach_cusp_tolerance 1e-3f
#define display_cusp_tolerance 1e-7f

__CONSTANT__ float hue_limit = 360.f;

__CONSTANT__ float ref_luminance = 100.0f;
__CONSTANT__ float L_A = 100.0f;
__CONSTANT__ float Y_b = 20.0f;
__CONSTANT__ float surround[3] = {0.9f, 0.59f, 0.9f}; // Dim surround
__CONSTANT__ float J_scale = 100.0f;
__CONSTANT__ float cam_nl_Y_reference = 100.0f;
__CONSTANT__ float cam_nl_offset = 0.2713f * cam_nl_Y_reference;
__CONSTANT__ float cam_nl_scale = 4.0f * cam_nl_Y_reference;

__CONSTANT__ float chroma_compress = 2.4f;
__CONSTANT__ float chroma_compress_fact = 3.3f;
__CONSTANT__ float chroma_expand = 1.3f;
__CONSTANT__ float chroma_expand_fact = 0.69f;
__CONSTANT__ float chroma_expand_thr = 0.5f;

__CONSTANT__ float gamma_minimum = 0.0f;
__CONSTANT__ float gamma_maximum = 5.0f;
__CONSTANT__ float gamma_search_step = 0.4f;
__CONSTANT__ float gamma_accuracy = 1e-5f;

// Gamut compression
__CONSTANT__ float smooth_cusps = 0.12f;
__CONSTANT__ float smooth_m = 0.27f;
__CONSTANT__ float cusp_mid_blend = 1.3f;

__CONSTANT__ float focus_gain_blend = 0.3f;
__CONSTANT__ float focus_distance = 1.35f;
__CONSTANT__ float focus_distance_scaling = 1.75f;

__CONSTANT__ float compression_threshold = 0.75f;

__CONSTANT__ int test_count = 5;
__CONSTANT__ float testPositions[test_count] = {0.01f, 0.1f, 0.5f, 0.8f, 0.99f};

#define PI (3.14159265358979323846f)

typedef struct {
        float2 red;
        float2 green;
        float2 blue;
        float2 white;
} Chromaticities;

typedef struct {
        float n;
        float n_r;
        float g;
        float t_1;
        float c_t;
        float s_2;
        float u_2;
        float m_2;
        float forward_limit;
        float inverse_limit;
        float log_peak;
} TSParams;

typedef struct {
        // Pre-computed conversion matrices and constants for conversions to/from JMh
        float MATRIX_RGB_to_CAM16_c[3][3];
        float MATRIX_CAM16_c_to_RGB[3][3];
        float MATRIX_cone_response_to_Aab[3][3];
        float MATRIX_Aab_to_cone_response[3][3];
        float F_L_n; // F_L normalised
        float cz;
        float inv_cz; // 1/cz
        float A_w_J;
        float inv_A_w_J; // 1/A_w_J
} JMhParams;

typedef struct {
        float peakLuminance;

        // JMh parameters
        JMhParams input_params;
        JMhParams reach_params;
        JMhParams limit_params;

        // Tonescale parameters
        TSParams ts;

        // Shared compression parameters
        float limit_J_max;
        float model_gamma_inv;
        float TABLE_reach_M[totalTableSize];

        // Chroma compression parameters
        float sat;
        float sat_thr;
        float compr;
        float chroma_compress_scale;

        // Gamut compression parameters
        float mid_J;
        float focus_dist;
        float lower_hull_gamma_inv;
        float TABLE_hues[totalTableSize];
        float TABLE_gamut_cusps[totalTableSize][3];
        float TABLE_upper_hull_gamma[totalTableSize];
        int hue_linearity_search_range[2];
} ODTParams;

typedef struct {
        // Hue-dependent gamut parameters
        float JMcusp[2];
        float gamma_bottom_inv;
        float gamma_top_inv;
        float focus_J;
        float analytical_threshold;
} HueDependentGamutParams;

// Academy Primaries 0
__CONSTANT__ Chromaticities AP0 = {
    {0.73470f, 0.26530f},
    {0.00000f, 1.00000f},
    {0.00010f, -0.07700f},
    {0.32168f, 0.33767f},
};

// Academy Primaries 1
__CONSTANT__ Chromaticities AP1 = {
    {0.713f, 0.293f},
    {0.165f, 0.830f},
    {0.128f, 0.044f},
    {0.32168f, 0.33767f},
};

// "Reach" Primaries - equal to ACES "AP1" primaries
__CONSTANT__ Chromaticities REACH_PRI = {
    {0.713f, 0.293f},
    {0.165f, 0.830f},
    {0.128f, 0.044f},
    {0.32168f, 0.33767f},
};

__DEVICE__ void clamp_f3(float out[3], float in[3], float clampMin, float clampMax) {
    // Note: Numeric constants can be used in place of a min or max value (i.e.
    // use HALF_NEG_INF in place of clampMin or HALF_POS_INF in place of clampMax)
    out[0] = _clampf(in[0], clampMin, clampMax);
    out[1] = _clampf(in[1], clampMin, clampMax);
    out[2] = _clampf(in[2], clampMin, clampMax);
}

// Matrix math
__DEVICE__ void fv_f_f3(float dst[3], float f, float v[3]) {
    // matrix * vector multiplication
    dst[0] = f * v[0];
    dst[1] = f * v[1];
    dst[2] = f * v[2];
}

__DEVICE__ void mv_33_3(float dst[3], float mat[3][3], float v[3]) {
    // matrix * vector multiplication
    dst[0] = mat[0][0] * v[0] + mat[0][1] * v[1] + mat[0][2] * v[2];
    dst[1] = mat[1][0] * v[0] + mat[1][1] * v[1] + mat[1][2] * v[2];
    dst[2] = mat[2][0] * v[0] + mat[2][1] * v[1] + mat[2][2] * v[2];
}

__DEVICE__ void vm_3_33(float dst[3], float v[3], float mat[3][3]) {
    // 1x3 vector * matrix multiplication
    dst[0] = mat[0][0] * v[0] + mat[1][0] * v[1] + mat[2][0] * v[2];
    dst[1] = mat[0][1] * v[0] + mat[1][1] * v[1] + mat[2][1] * v[2];
    dst[2] = mat[0][2] * v[0] + mat[1][2] * v[1] + mat[2][2] * v[2];
}

__DEVICE__ void copy_f3(float to[3], float from[3]) {
    to[0] = from[0];
    to[1] = from[1];
    to[2] = from[2];
}

__DEVICE__ void copy_mat_33(float to[3][3], float from[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            to[i][j] = from[i][j];
        }
    }
}

__DEVICE__ void mm_33_33(float dest[3][3], float a[3][3], float b[3][3]) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j];
        }
    }
}

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ void powf3(float out[3], float base[3], float exp) {
    out[0] = powf(base[0], exp);
    out[1] = powf(base[1], exp);
    out[2] = powf(base[2], exp);
}

__DEVICE__ inline float pow2f(float base) {
    return base * base;
}

__DEVICE__ float powi(float x, int exp) {
    float out = 1.0f;
    int abs_exp = exp < 0 ? exp * -1 : exp;
    for (int i = 0; i < abs_exp; ++i) {
        out *= x;
    }
    if (exp < 0) {
        out = 1.0f / out;
    }
    return out;
}

__DEVICE__ void inverse_33(float dst[3][3], float m[3][3]) {
    // from https://ardoris.wordpress.com/2008/07/18/general-formula-for-the-inverse-of-a-3x3-matrix/
    float det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

    dst[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
    dst[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
    dst[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
    dst[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
    dst[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
    dst[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
    dst[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
    dst[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
    dst[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
}

__DEVICE__ void mat_fill(float dest[3][3], float fill) {
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            dest[i][j] = fill;
        }
    }
}

__DEVICE__ void diagonal_matrix(float dest[3][3], float3 diagonal) {
    mat_fill(dest, 0.0f);
    dest[0][0] = diagonal.x;
    dest[1][1] = diagonal.y;
    dest[2][2] = diagonal.z;
}

__DEVICE__ void RGBtoXYZ_f33(float M[3][3], Chromaticities C, float Y) {
    // X and Z values of RGB value (1, 1, 1), or "white"
    float X = C.white[0] * Y / C.white[1];
    float Z = (1.f - C.white[0] - C.white[1]) * Y / C.white[1];

    // Scale factors for matrix rows
    float d = C.red[0] * (C.blue[1] - C.green[1]) + C.blue[0] * (C.green[1] - C.red[1]) + C.green[0] * (C.red[1] - C.blue[1]);

    float Sr = (X * (C.blue[1] - C.green[1]) - C.green[0] * (Y * (C.blue[1] - 1) + C.blue[1] * (X + Z)) +
                C.blue[0] * (Y * (C.green[1] - 1) + C.green[1] * (X + Z))) /
               d;

    float Sg = (X * (C.red[1] - C.blue[1]) + C.red[0] * (Y * (C.blue[1] - 1) + C.blue[1] * (X + Z)) -
                C.blue[0] * (Y * (C.red[1] - 1) + C.red[1] * (X + Z))) /
               d;

    float Sb = (X * (C.green[1] - C.red[1]) - C.red[0] * (Y * (C.green[1] - 1) + C.green[1] * (X + Z)) +
                C.green[0] * (Y * (C.red[1] - 1) + C.red[1] * (X + Z))) /
               d;

    // Assemble the matrix
    M[0][0] = Sr * C.red[0];
    M[0][1] = Sr * C.red[1];
    M[0][2] = Sr * (1.f - C.red[0] - C.red[1]);
    M[1][0] = Sg * C.green[0];
    M[1][1] = Sg * C.green[1];
    M[1][2] = Sg * (1.f - C.green[0] - C.green[1]);
    M[2][0] = Sb * C.blue[0];
    M[2][1] = Sb * C.blue[1];
    M[2][2] = Sb * (1.f - C.blue[0] - C.blue[1]);
}

__DEVICE__ void XYZtoRGB_f33(float dst[3][3], Chromaticities C, float Y) {
    float temp[3][3];
    RGBtoXYZ_f33(temp, C, Y);
    inverse_33(dst, temp);
}

__DEVICE__ float _post_adaptation_cone_response_compression_fwd(float Rc) {
    const float F_L_Y = powf(Rc, 0.42f);
    const float Ra = (F_L_Y) / (cam_nl_offset + F_L_Y);
    return Ra;
}

__DEVICE__ float post_adaptation_cone_response_compression_fwd(float v) {
    const float abs_v = _fabs(v);
    const float Ra = _post_adaptation_cone_response_compression_fwd(abs_v);
    return copysign(Ra, v);
}

__DEVICE__ float3 f3_to_float3(float x[3]) {
    return make_float3(x[0], x[1], x[2]);
}

__DEVICE__ JMhParams init_JMhParams(Chromaticities prims) {
    const Chromaticities CAM16_PRI = {
        {0.8336f, 0.1735f},
        {2.3854f, -1.4659f},
        {0.087f, -0.125f},
        {0.333f, 0.333f},
    };

    float MATRIX_16[3][3];
    XYZtoRGB_f33(MATRIX_16, CAM16_PRI, 1.0f);

    float base_cone_response_to_Aab[3][3] = {
        {2.f, 1.f, 1.f / 9.f},
        {1.f, -12.f / 11.f, 1.f / 9.f},
        {1.f / 20.f, 1.f / 11.f, -2.f / 9.f},
    };

    float RGB_TO_XYZ[3][3];
    RGBtoXYZ_f33(RGB_TO_XYZ, prims, 1.0f);
    float XYZ_w[3];
    float ref_luminance_vec[3] = {ref_luminance, ref_luminance, ref_luminance};
    vm_3_33(XYZ_w, ref_luminance_vec, RGB_TO_XYZ);

    float Y_w = XYZ_w[1];

    // Step 0 - Converting CIE XYZ tristimulus values to sharpened RGB values
    float RGB_w[3];
    vm_3_33(RGB_w, XYZ_w, MATRIX_16);

    // Viewing condition dependent parameters
    const float k = 1.f / (5.f * L_A + 1.f);
    const float k4 = k * k * k * k;
    const float F_L = 0.2f * k4 * (5.f * L_A) + 0.1f * pow2f((1.f - k4)) * powf(5.f * L_A, 1.f / 3.f);

    const float F_L_n = F_L / ref_luminance;
    const float model_gamma = surround[1] * (1.48f + _sqrtf(Y_b / ref_luminance));
    const float cz = model_gamma;

    float D_RGB[3] = {F_L_n * Y_w / RGB_w[0], F_L_n * Y_w / RGB_w[1], F_L_n * Y_w / RGB_w[2]};

    float RGB_wc[3] = {D_RGB[0] * RGB_w[0], D_RGB[1] * RGB_w[1], D_RGB[2] * RGB_w[2]};

    float RGB_Aw[3] = {post_adaptation_cone_response_compression_fwd(RGB_wc[0]),
                       post_adaptation_cone_response_compression_fwd(RGB_wc[1]),
                       post_adaptation_cone_response_compression_fwd(RGB_wc[2])};

    float cam_nl_scale_mat[3][3];
    diagonal_matrix(cam_nl_scale_mat, make_float3(cam_nl_scale, cam_nl_scale, cam_nl_scale));
    float cone_response_to_Aab[3][3];
    mm_33_33(cone_response_to_Aab, cam_nl_scale_mat, base_cone_response_to_Aab);
    float A_w = cone_response_to_Aab[0][0] * RGB_Aw[0] + cone_response_to_Aab[1][0] * RGB_Aw[1] + cone_response_to_Aab[2][0] * RGB_Aw[2];
    float A_w_J = _post_adaptation_cone_response_compression_fwd(F_L);

    // Prescale the CAM16 LMS responses to directly provide for chromatic adaptation
    float M1[3][3];
    mm_33_33(M1, RGB_TO_XYZ, MATRIX_16);
    float M2[3][3];
    diagonal_matrix(M2, make_float3(ref_luminance, ref_luminance, ref_luminance));
    float MATRIX_RGB_to_CAM16[3][3];
    mm_33_33(MATRIX_RGB_to_CAM16, M1, M2);
    float MATRIX_RGB_to_CAM16_c[3][3];

    float d_rgb_mat[3][3];
    diagonal_matrix(d_rgb_mat, f3_to_float3(D_RGB));
    mm_33_33(MATRIX_RGB_to_CAM16_c, MATRIX_RGB_to_CAM16, d_rgb_mat);

    float MATRIX_cone_response_to_Aab[3][3] = {
        {cone_response_to_Aab[0][0] / A_w, cone_response_to_Aab[0][1] * 43.f * surround[2], cone_response_to_Aab[0][2] * 43.f * surround[2]},
        {cone_response_to_Aab[1][0] / A_w, cone_response_to_Aab[1][1] * 43.f * surround[2], cone_response_to_Aab[1][2] * 43.f * surround[2]},
        {cone_response_to_Aab[2][0] / A_w, cone_response_to_Aab[2][1] * 43.f * surround[2], cone_response_to_Aab[2][2] * 43.f * surround[2]}};

    JMhParams p;
    copy_mat_33(p.MATRIX_RGB_to_CAM16_c, MATRIX_RGB_to_CAM16_c);
    inverse_33(p.MATRIX_CAM16_c_to_RGB, MATRIX_RGB_to_CAM16_c);
    copy_mat_33(p.MATRIX_cone_response_to_Aab, MATRIX_cone_response_to_Aab);
    inverse_33(p.MATRIX_Aab_to_cone_response, MATRIX_cone_response_to_Aab);
    p.F_L_n = F_L_n;
    p.cz = cz;
    p.inv_cz = 1.f / cz;
    p.A_w_J = A_w_J;
    p.inv_A_w_J = 1.f / A_w_J;

    return p;
}

// Tonescale pre-calculations
__DEVICE__ TSParams init_TSParams(float peakLuminance) {

    // Preset constants that set the desired behavior for the curve
    const float n = peakLuminance;

    const float n_r = 100.0f;      // normalized white in nits (what 1.0f should be)
    const float g = 1.15f;         // surround / contrast
    const float c = 0.18f;         // anchor for 18% grey
    const float c_d = 10.013f;     // output luminance of 18% grey (in nits)
    const float w_g = 0.14f;       // change in grey between different peak luminance
    const float t_1 = 0.04f;       // shadow toe or flare/glare compensation
    const float r_hit_min = 128.; // scene-referred value "hitting the roof" for SDR (e.g. when n = 100 nits)
    const float r_hit_max = 896.; // scene-referred value "hitting the roof" for when n = 10000 nits

    // Calculate output constants
    const float r_hit = r_hit_min + (r_hit_max - r_hit_min) * (_logf(n / n_r) / _logf(10000.f / 100.f));
    const float m_0 = (n / n_r);
    const float m_1 = 0.5f * (m_0 + _sqrtf(m_0 * (m_0 + 4.f * t_1)));
    const float u = powf((r_hit / m_1) / ((r_hit / m_1) + 1), g);
    const float m = m_1 / u;
    const float w_i = _logf(n / 100.f) / _logf(2.f);
    const float c_t = c_d / n_r * (1.f + w_i * w_g);
    const float g_ip = 0.5f * (c_t + _sqrtf(c_t * (c_t + 4.f * t_1)));
    const float g_ipp2 = -(m_1 * powf((g_ip / m), (1.f / g))) / (powf(g_ip / m, 1.f / g) - 1.f);
    const float w_2 = c / g_ipp2;
    const float s_2 = w_2 * m_1;
    const float u_2 = powf((r_hit / m_1) / ((r_hit / m_1) + w_2), g);
    const float m_2 = m_1 / u_2;

    TSParams p;
    p.n = n;
    p.n_r = n_r;
    p.g = g;
    p.t_1 = t_1;
    p.c_t = c_t;
    p.s_2 = s_2;
    p.u_2 = u_2;
    p.m_2 = m_2;
    p.forward_limit = 8.0f * r_hit;
    p.inverse_limit = n / (u_2 * n_r);
    p.log_peak = _log10f(n / n_r);

    return p;
}

__DEVICE__ float Achromatic_n_to_J(float A, float cz) {
    return J_scale * powf(A, cz);
}

__DEVICE__ float Y_to_J(float Y, JMhParams p) {
    float abs_Y = _fabs(Y);
    float Ra = _post_adaptation_cone_response_compression_fwd(abs_Y * p.F_L_n);
    float J = Achromatic_n_to_J(Ra * p.inv_A_w_J, p.cz);

    return _copysignf(J, Y);
}

__DEVICE__ float base_hue_for_position(int i_lo, int table_size) {
    float result = i_lo * hue_limit / table_size;
    return result;
}

__DEVICE__ float degrees_to_radians(float degrees) {
    return degrees / 180.0f * PI;
}

__DEVICE__ float radians_to_degrees(float radians) {
    return radians * 180.0f / PI;
}

__DEVICE__ float wrap_to_360(float hue) {
    float y = _fmod(hue, 360.f);
    if (y < 0.f) {
        y = y + 360.f;
    }
    return y;
}

__DEVICE__ float J_to_Achromatic_n(float J, float inv_cz) {
    return powf(J * (1.f / J_scale), inv_cz);
}

__DEVICE__ void JMh_to_Aab(float Aab[3], float JMh[3], JMhParams p) {
    float J = JMh[0];
    float M = JMh[1];
    float h = JMh[2];
    float h_rad = degrees_to_radians(h);
    float cos_hr = _cosf(h_rad);
    float sin_hr = _sinf(h_rad);

    float A = J_to_Achromatic_n(J, p.inv_cz);
    float a = M * cos_hr;
    float b = M * sin_hr;
    Aab[0] = A;
    Aab[1] = a;
    Aab[2] = b;
}

__DEVICE__ float _post_adaptation_cone_response_compression_inv(float Ra) {
    const float Ra_lim = _fminf(Ra, 0.99f);
    const float F_L_Y = (cam_nl_offset * Ra_lim) / (1.f - Ra_lim);
    const float Rc = powf(F_L_Y, 1.f / 0.42f);
    return Rc;
}

__DEVICE__ float post_adaptation_cone_response_compression_inv(float v) {
    const float abs_v = _fabs(v);
    const float Rc = _post_adaptation_cone_response_compression_inv(abs_v);
    return _copysignf(Rc, v);
}

__DEVICE__ void Aab_to_RGB(float rgb[3], float Aab[3], JMhParams p) {
    float rgb_a[3];
    vm_3_33(rgb_a, Aab, p.MATRIX_Aab_to_cone_response);

    float rgb_m[3] = {post_adaptation_cone_response_compression_inv(rgb_a[0]),
                      post_adaptation_cone_response_compression_inv(rgb_a[1]),
                      post_adaptation_cone_response_compression_inv(rgb_a[2])};

    vm_3_33(rgb, rgb_m, p.MATRIX_CAM16_c_to_RGB);
}

__DEVICE__ void RGB_to_Aab(float Aab[3], float RGB[3], JMhParams p) {
    float rgb_m[3];
    vm_3_33(rgb_m, RGB, p.MATRIX_RGB_to_CAM16_c);

    float rgb_a[3] = {post_adaptation_cone_response_compression_fwd(rgb_m[0]),
                      post_adaptation_cone_response_compression_fwd(rgb_m[1]),
                      post_adaptation_cone_response_compression_fwd(rgb_m[2])};

    vm_3_33(Aab, rgb_a, p.MATRIX_cone_response_to_Aab);
}

__DEVICE__ void Aab_to_JMh(float JMh[3], float Aab[3], JMhParams p) {
    JMh[0] = 0.f;
    JMh[1] = 0.f;
    JMh[2] = 0.f;
    if (Aab[0] <= 0.f) {
        return;
    }
    float J = Achromatic_n_to_J(Aab[0], p.cz);
    float M = _sqrtf(Aab[1] * Aab[1] + Aab[2] * Aab[2]);
    float h_rad = _atan2f(Aab[2], Aab[1]);
    float h = wrap_to_360(radians_to_degrees(h_rad));

    JMh[0] = J;
    JMh[1] = M;
    JMh[2] = h;
}

// output to rgb parameter
__DEVICE__ void JMh_to_RGB(float rgb[3], float JMh[3], JMhParams p) {
    float Aab[3];
    JMh_to_Aab(Aab, JMh, p);
    Aab_to_RGB(rgb, Aab, p);
}

__DEVICE__ void RGB_to_JMh(float JMh[3], float RGB[3], JMhParams p) {
    float Aab[3];
    RGB_to_Aab(Aab, RGB, p);
    Aab_to_JMh(JMh, Aab, p);
}

// Table building functions
__DEVICE__ bool any_below_zero(float newLimitRGB[3]) {
    return (newLimitRGB[0] < 0.f || newLimitRGB[1] < 0.f || newLimitRGB[2] < 0.f);
}

// Finds reach gamut M value at limitJmax
__DEVICE__ void make_reach_m_table(float dst[totalTableSize], JMhParams params, float limitJmax) {

    for (int i = 0; i < tableSize; i = i + 1) {
        // float i_float = i;
        float hue = base_hue_for_position(i, tableSize);

        const float search_range = 50.f;
        const float search_maximum = 1300.f;
        float low = 0.f;
        float high = low + search_range;
        bool outside = false;

        while ((outside != true) & (high < search_maximum)) {
            float searchJMh[3] = {limitJmax, high, hue};
            float newLimitRGB[3];
            JMh_to_RGB(newLimitRGB, searchJMh, params);
            outside = any_below_zero(newLimitRGB);
            if (outside == false) {
                low = high;
                high = high + search_range;
            }
        }

        while (high - low > 1e-2f) {
            float sampleM = (high + low) / 2.f;
            float searchJMh[3] = {limitJmax, sampleM, hue};
            float newLimitRGB[3];
            JMh_to_RGB(newLimitRGB, searchJMh, params);
            outside = any_below_zero(newLimitRGB);
            if (outside) {
                high = sampleM;
            } else {
                low = sampleM;
            }
        }

        dst[i + baseIndex] = high;
    }

    // Copy last populated entry to first empty spot
    dst[0] = dst[tableSize];

    // Copy first populated entry to last empty spot
    dst[baseIndex + tableSize] = dst[baseIndex];
}

__DEVICE__ void generate_unit_cube_cusp_corners(float result[3], int corner) {

    // Generation order R, Y, G, C, B, M to ensure hues rotate in correct order
    if (((corner + 1) % cuspCornerCount) < 3)
        result[0] = 1;
    else
        result[0] = 0;
    if (((corner + 5) % cuspCornerCount) < 3)
        result[1] = 1;
    else
        result[1] = 0;
    if (((corner + 3) % cuspCornerCount) < 3)
        result[2] = 1;
    else
        result[2] = 0;
}

__DEVICE__ void find_reach_corners_table(float JMh_corners[totalCornerCount][3], JMhParams params_reach, ODTParams p) {
    // We need to find the value of JMh that corresponds to limitJ for each
    // corner This is done by scaling the unit corners converting to JMh until
    // the J value is near the limitJ
    // As an optimisation we use the equivalent Achromatic value to search for
    // the J value and avoid the non-linear transform during the search.
    // Strictly speaking we should only need to find the R, G and  B "corners"
    // as the reach is unbounded and as such does not form a cube, but is formed
    // by the transformed 3 lower planes of the cube and the plane at J = limitJ
    float temp_JMh_corners[cuspCornerCount][3];

    float limitA = J_to_Achromatic_n(p.limit_J_max, params_reach.inv_cz);

    int min_index = 0;
    for (int i = 0; i != cuspCornerCount; i = i + 1) {
        float rgb_vector[3];
        generate_unit_cube_cusp_corners(rgb_vector, i);

        float lower = 0.0f;
        float upper = p.ts.forward_limit;

        while ((upper - lower) > reach_cusp_tolerance) {
            float test = (lower + upper) / 2.f;
            float test_corner[3];
            fv_f_f3(test_corner, test, rgb_vector);
            float Aab[3];
            RGB_to_Aab(Aab, test_corner, params_reach);
            float A = Aab[0];
            if (A < limitA) {
                lower = test;
            } else {
                upper = test;
            }
        }

        float upper_rgb_temp[3];
        fv_f_f3(upper_rgb_temp, upper, rgb_vector);

        RGB_to_JMh(temp_JMh_corners[i], upper_rgb_temp, params_reach);

        if (temp_JMh_corners[i][2] < temp_JMh_corners[min_index][2])
            min_index = i;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; i = i + 1) {
        copy_f3(JMh_corners[i + 1], temp_JMh_corners[(i + min_index) % cuspCornerCount]);
    }

    // Copy end elements to create a cycle
    copy_f3(JMh_corners[0], JMh_corners[cuspCornerCount]);
    copy_f3(JMh_corners[cuspCornerCount + 1], JMh_corners[1]);

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0][2] = JMh_corners[0][2] - hue_limit;
    JMh_corners[cuspCornerCount + 1][2] = JMh_corners[cuspCornerCount + 1][2] + hue_limit;
}

__DEVICE__ void build_limiting_cusp_corners_tables(float RGB_corners[totalCornerCount][3],
                                                   float JMh_corners[totalCornerCount][3],
                                                   JMhParams params,
                                                   float peakLuminance) {
    // We calculate the RGB and JMh values for the limiting gamut cusp corners
    // They are then arranged into a cycle with the lowest JMh value at [1] to
    // allow for hue wrapping
    float temp_RGB_corners[cuspCornerCount][3];
    float temp_JMh_corners[cuspCornerCount][3];

    int min_index = 0;
    for (int i = 0; i != cuspCornerCount; i = i + 1) {
        float temp[3];
        generate_unit_cube_cusp_corners(temp, i);
        fv_f_f3(temp_RGB_corners[i], peakLuminance / ref_luminance, temp);
        RGB_to_JMh(temp_JMh_corners[i], temp_RGB_corners[i], params);
        if (temp_JMh_corners[i][2] < temp_JMh_corners[min_index][2])
            min_index = 1;
    }

    // Rotate entries placing lowest at [1] (not [0])
    for (int i = 0; i != cuspCornerCount; i = i + 1) {
        copy_f3(RGB_corners[i + 1], temp_RGB_corners[(i + min_index) % cuspCornerCount]);
        copy_f3(JMh_corners[i + 1], temp_JMh_corners[(i + min_index) % cuspCornerCount]);
    }

    // Copy end elements to create a cycle
    copy_f3(RGB_corners[0], RGB_corners[cuspCornerCount]);
    copy_f3(RGB_corners[cuspCornerCount + 1], RGB_corners[1]);
    copy_f3(JMh_corners[0], JMh_corners[cuspCornerCount]);
    copy_f3(JMh_corners[cuspCornerCount + 1], JMh_corners[1]);

    // Wrap the hues, to maintain monotonicity these entries will fall outside [0.0, hue_limit)
    JMh_corners[0][2] = JMh_corners[0][2] - hue_limit;
    JMh_corners[cuspCornerCount + 1][2] = JMh_corners[cuspCornerCount + 1][2] + hue_limit;
}

__DEVICE__ void extract_sorted_cube_hues(float sorted_hues[max_sorted_corners],
                                         float reach_JMh[totalCornerCount][3],
                                         float limit_JMh[totalCornerCount][3]) {
    // Basic merge of 2 sorted arrays, extracting the unique hues.
    // Return the count of the unique hues
    int idx = 0;
    int reach_idx = 1;
    int limit_idx = 1;
    while ((reach_idx < (cuspCornerCount + 1)) || (limit_idx < (cuspCornerCount + 1))) {
        float reach_hue = reach_JMh[reach_idx][2];
        float limit_hue = limit_JMh[limit_idx][2];
        if (reach_hue == limit_hue) {
            sorted_hues[idx] = reach_hue;
            reach_idx = reach_idx + 1;
            limit_idx = limit_idx + 1; // When equal consume both
        } else {
            if (reach_hue < limit_hue) {
                sorted_hues[idx] = reach_hue;
                reach_idx = reach_idx + 1;
            } else {
                sorted_hues[idx] = limit_hue;
                limit_idx = limit_idx + 1;
            }
        }
        idx = idx + 1;
    }
}

__DEVICE__ void build_hue_sample_interval(
    float mod_hue_table[totalTableSize], int samples, float lower, float upper, float hue_table[totalTableSize], int base) {
    float delta = (upper - lower) / samples;
    int i;
    for (i = 0; i != samples; i = i + 1) {
        mod_hue_table[base + i] = lower + i * delta;
    }
}

__DEVICE__ void build_hue_table(float hue_table[totalTableSize], float sorted_hues[max_sorted_corners]) {

    float ideal_spacing = tableSize / hue_limit;
    int samples_count[2 * cuspCornerCount + 2];
    int last_idx;
    int min_index;
    if (sorted_hues[0] == 0.0f) {
        min_index = 0;
    } else {
        min_index = 1;
    }
    int hue_idx;

    for (hue_idx = 0; hue_idx != max_sorted_corners; hue_idx = hue_idx + 1) {
        // float raw_idx = _round(sorted_hues[hue_idx] * ideal_spacing);
        int nominal_idx = _fminf(_fmaxf(_round(sorted_hues[hue_idx] * ideal_spacing), min_index), tableSize - 1);

        if (last_idx == nominal_idx) {
            // Last two hues should sample at same index, need to adjust them
            // Adjust previous sample down if we can
            if (hue_idx > 1 && samples_count[hue_idx - 2] != (samples_count[hue_idx - 1] - 1)) {
                samples_count[hue_idx - 1] = samples_count[hue_idx - 1] - 1;
            } else {
                nominal_idx = nominal_idx + 1;
            }
        }
        samples_count[hue_idx] = (int)_fminf((float)nominal_idx, (float)tableSize - 1);
        min_index = nominal_idx;
        last_idx = min_index;
    }

    int total_samples = 0;
    // Special cases for ends
    int i = 0;
    build_hue_sample_interval(hue_table, samples_count[i], 0.0f, sorted_hues[i], hue_table, total_samples + 1);
    total_samples = total_samples + samples_count[i];

    for (i = i + 1; i != max_sorted_corners; i = i + 1) {
        int samples = samples_count[i] - samples_count[i - 1];
        build_hue_sample_interval(hue_table, samples, sorted_hues[i - 1], sorted_hues[i], hue_table, total_samples + 1);
        total_samples = total_samples + samples;
    }
    build_hue_sample_interval(hue_table, tableSize - total_samples, sorted_hues[i - 1], hue_limit, hue_table, total_samples + 1);

    hue_table[0] = hue_table[baseIndex + tableSize - 1] - hue_limit;
    hue_table[baseIndex + tableSize] = hue_table[baseIndex] + hue_limit;
}

__DEVICE__ float midpoint(float low, float high) {
    return (low + high) / 2.f;
}

__DEVICE__ float lerp(float a, float b, float t) {
    return a + t * (b - a);
}

__DEVICE__ void lerp_f3(float lerped[3], float a[3], float b[3], float t) {
    lerped[0] = lerp(a[0], b[0], t);
    lerped[1] = lerp(a[1], b[1], t);
    lerped[2] = lerp(a[2], b[2], t);
}

__DEVICE__ void find_display_cusp_for_hue(float return_JM[2],
                                          float hue,
                                          float RGB_corners[totalCornerCount][3],
                                          float JMh_corners[totalCornerCount][3],
                                          JMhParams params,
                                          float previous[2]) {
    // This works by finding the required line segment between two of the XYZ
    // cusp corners, then binary searching along the line calculating the JMh of
    // points along the line till we find the required value. All values on the
    // line segments are valid cusp locations.

    int upper_corner = 1;
    int found = 0;
    for (int i = upper_corner; i != totalCornerCount && !found; i = i + 1) {
        if (JMh_corners[i][2] > hue) {
            upper_corner = i;
            found = 1;
        }
    }
    int lower_corner = upper_corner - 1;

    // hue should now be within [lower_corner, upper_corner), handle exact match
    if (JMh_corners[lower_corner][2] == hue) {
        return_JM[0] = JMh_corners[lower_corner][0];
        return_JM[1] = JMh_corners[lower_corner][1];
        return;
    }

    // search by lerping between RGB corners for the hue
    float cusp_lower[3];
    copy_f3(cusp_lower, RGB_corners[lower_corner]);
    float cusp_upper[3];
    copy_f3(cusp_upper, RGB_corners[upper_corner]);
    float sample[3];

    float sample_t;
    float lower_t = 0.0f;
    if (upper_corner == previous[0])
        lower_t = previous[1];
    float upper_t = 1.0f;

    float JMh[3];

    // There is an edge case where we need to search towards the range when
    // across the [0.0, hue_limit] boundary each edge needs the directions
    // swapped. This is handled by comparing against the appropriate corner to
    // make sure we are still in the expected range between the lower and upper
    // corner hue limits
    while ((upper_t - lower_t) > display_cusp_tolerance) {
        sample_t = midpoint(lower_t, upper_t);
        lerp_f3(sample, cusp_lower, cusp_upper, sample_t);
        RGB_to_JMh(JMh, sample, params);
        if (JMh[2] < JMh_corners[lower_corner][2]) {
            upper_t = sample_t;
        } else if (JMh[2] >= JMh_corners[upper_corner][2]) {
            lower_t = sample_t;
        } else if (JMh[2] > hue) {
            upper_t = sample_t;
        } else {
            lower_t = sample_t;
        }
    }

    // Use the midpoint of the final interval for the actual samples
    sample_t = midpoint(lower_t, upper_t);
    lerp_f3(sample, cusp_lower, cusp_upper, sample_t);
    RGB_to_JMh(JMh, sample, params);

    return_JM[0] = JMh[0];
    return_JM[1] = JMh[1];
}

__DEVICE__ void build_cusp_table(float output_table[totalTableSize][3],
                                 float hue_table[totalTableSize],
                                 float RGB_corners[totalCornerCount][3],
                                 float JMh_corners[totalCornerCount][3],
                                 JMhParams params) {
    float previous[2] = {0.0f, 0.0f};

    for (int i = baseIndex; i != totalTableSize; i = i + 1) {
        float hue = hue_table[i];
        float JM[2];
        find_display_cusp_for_hue(JM, hue, RGB_corners, JMh_corners, params, previous);
        output_table[i][0] = JM[0];
        output_table[i][1] = JM[1] * (1.f + smooth_m * smooth_cusps);
        output_table[i][2] = hue;
    }

    // Copy last nominal entry to start
    output_table[0][0] = output_table[tableSize][0];
    output_table[0][1] = output_table[tableSize][1];
    output_table[0][2] = hue_table[0];

    // Copy first nominal entry to end
    output_table[baseIndex + tableSize][0] = output_table[baseIndex][0];
    output_table[baseIndex + tableSize][1] = output_table[baseIndex][1];
    output_table[baseIndex + tableSize][2] = hue_table[baseIndex + tableSize];
}

__DEVICE__ void
make_uniform_hue_gamut_table(float cusp_JMh_table[totalTableSize][3], JMhParams reach_params, JMhParams limit_params, ODTParams p) {
    // The principal here is to sample the hues as uniformly as possible, whilst
    // ensuring we sample the corners of the limiting gamut and the reach
    // primaries at limit J Max
    //
    // The corners are calculated then the hues are extracted and merged to form
    // a unique sorted hue list We then build the hue table from the list, those
    // hues are then used to compute the JMh of the limiting gamut cusp.

    float reach_JMh_corners[totalCornerCount][3];
    float limiting_RGB_corners[totalCornerCount][3];
    float limiting_JMh_corners[totalCornerCount][3];

    find_reach_corners_table(reach_JMh_corners, reach_params, p);
    build_limiting_cusp_corners_tables(limiting_RGB_corners, limiting_JMh_corners, limit_params, p.peakLuminance);
    float sorted_hues[max_sorted_corners];
    extract_sorted_cube_hues(sorted_hues, reach_JMh_corners, limiting_JMh_corners);

    float hue_table[totalTableSize];
    build_hue_table(hue_table, sorted_hues);

    build_cusp_table(cusp_JMh_table, hue_table, limiting_RGB_corners, limiting_JMh_corners, limit_params);
}

__DEVICE__ float compute_focus_J(float cusp_J, float mid_J, float limit_J_max) {
    return lerp(cusp_J, mid_J, _fminf(1, cusp_mid_blend - (cusp_J / limit_J_max)));
}

__DEVICE__ float get_focus_gain(float J, float analytical_threshold, float limit_J_max, float focus_dist) {
    float gain = limit_J_max * focus_dist;

    if (J > analytical_threshold) {
        // Approximate inverse required above threshold due to the introduction of J in the calculation
        float gain_adjustment = _log10f((limit_J_max - analytical_threshold) / _fmaxf(0.0001f, limit_J_max - J));
        gain_adjustment = gain_adjustment * gain_adjustment + 1.f;
        gain = gain * gain_adjustment;
    }

    return gain;
}

__DEVICE__ float solve_J_intersect(float J, float M, float focusJ, float maxJ, float slope_gain) {
    const float M_scaled = M / slope_gain;
    const float a = M_scaled / focusJ;

    if (J < focusJ) {
        const float b = 1.f - M_scaled;
        const float c = -J;
        const float det = b * b - 4.f * a * c;
        const float root = _sqrtf(det);
        return -2.f * c / (b + root);
    } else {
        const float b = -(1.f + M_scaled + maxJ * a);
        const float c = maxJ * M_scaled + J;
        const float det = b * b - 4.f * a * c;
        const float root = _sqrtf(det);
        return -2.f * c / (b - root);
    }
}

__DEVICE__ float compute_compression_vector_slope(float intersect_J, float focus_J, float limit_J_max, float slope_gain) {
    float direction_scalar;
    if (intersect_J < focus_J) {
        direction_scalar = intersect_J;
    } else {
        direction_scalar = limit_J_max - intersect_J;
    }
    return direction_scalar * (intersect_J - focus_J) / (focus_J * slope_gain);
}

__DEVICE__ void generate_gamma_test_data(float JMcusp[2],
                                         float hue,
                                         float limit_J_max,
                                         float mid_J,
                                         float focus_dist,
                                         float test_JMh[test_count][3],
                                         float J_intersect_source[test_count],
                                         float slopes[test_count],
                                         float J_intersect_cusp[test_count]) {
    float analytical_threshold = lerp(JMcusp[0], limit_J_max, focus_gain_blend);
    float focus_J = compute_focus_J(JMcusp[0], mid_J, limit_J_max);

    for (int testIndex = 0; testIndex != test_count; testIndex = testIndex + 1) {
        float test_J = lerp(JMcusp[0], limit_J_max, testPositions[testIndex]);
        float slope_gain = get_focus_gain(test_J, analytical_threshold, limit_J_max, focus_dist);
        float J_intersect = solve_J_intersect(test_J, JMcusp[1], focus_J, limit_J_max, slope_gain);
        float slope = compute_compression_vector_slope(J_intersect, focus_J, limit_J_max, slope_gain);
        float J_cusp = solve_J_intersect(JMcusp[0], JMcusp[1], focus_J, limit_J_max, slope_gain);

        // Store values in parallel arrays
        test_JMh[testIndex][0] = test_J;
        test_JMh[testIndex][1] = JMcusp[1];
        test_JMh[testIndex][2] = hue;
        J_intersect_source[testIndex] = J_intersect;
        slopes[testIndex] = slope;
        J_intersect_cusp[testIndex] = J_cusp;
    }
}

__DEVICE__ float estimate_line_and_boundary_intersection_M(
    float J_axis_intersect, float slope, float inv_gamma, float J_max, float M_max, float J_intersection_reference) {
    // Line defined by     J = slope * x + J_axis_intersect
    // Boundary defined by J = J_max * (x / M_max) ^ (1/inv_gamma)
    // Approximate as we do not want to iteratively solve intersection of a
    // straight line and an exponential

    // We calculate a shifted intersection from the original intersection using
    // the inverse of the exponential and the provided reference
    const float normalised_J = J_axis_intersect / J_intersection_reference;
    const float shifted_intersection = J_intersection_reference * pow(normalised_J, inv_gamma);

    // Now we find the M intersection of two lines
    // line from origin to J,M Max       l1(x) = J/M * x
    // line from J Intersect' with slope l2(x) = slope * x + Intersect'

    // return shifted_intersection / ((J_max / M_max) - slope);
    return shifted_intersection * M_max / (J_max - slope * M_max);
}

// Smooth minimum about the scaled reference, based upon a cubic polynomial
__DEVICE__ float smin_scaled(float a, float b, float scale_reference) {
    const float s_scaled = smooth_cusps * scale_reference;
    const float h = _fmaxf(s_scaled - _fabs(a - b), 0.0f) / s_scaled;
    return _fminf(a, b) - h * h * h * s_scaled * (1.f / 6.f);
}

__DEVICE__ float find_gamut_boundary_intersection(float JM_cusp[2],
                                                  float J_max,
                                                  float gamma_top_inv,
                                                  float gamma_bottom_inv,
                                                  float J_intersect_source,
                                                  float slope,
                                                  float J_intersect_cusp) {
    const float M_boundary_lower =
        estimate_line_and_boundary_intersection_M(J_intersect_source, slope, gamma_bottom_inv, JM_cusp[0], JM_cusp[1], J_intersect_cusp);

    // The upper hull is flipped and thus 'zeroed' at J_max
    // Also note we negate the slope
    const float f_J_intersect_cusp = J_max - J_intersect_cusp;
    const float f_J_intersect_source = J_max - J_intersect_source;
    const float f_JM_cusp_J = J_max - JM_cusp[0];
    const float M_boundary_upper =
        estimate_line_and_boundary_intersection_M(f_J_intersect_source, -slope, gamma_top_inv, f_JM_cusp_J, JM_cusp[1], f_J_intersect_cusp);

    // Smooth minimum between the two calculated values for the M component
    float M_boundary = smin_scaled(M_boundary_lower, M_boundary_upper, JM_cusp[1]);
    return M_boundary;
}

__DEVICE__ bool outside_hull(float rgb[3], float maxRGBtestVal) {
    return rgb[0] > maxRGBtestVal || rgb[1] > maxRGBtestVal || rgb[2] > maxRGBtestVal;
}

__DEVICE__ bool evaluate_gamma_fit(float JMcusp[2],
                                   float test_JMh[test_count][3],
                                   float J_intersect_source[test_count],
                                   float slopes[test_count],
                                   float J_intersect_cusp[test_count],
                                   float top_gamma_inv,
                                   float peakLuminance,
                                   float limit_J_max,
                                   float lower_hull_gamma_inv,
                                   JMhParams limit_params) {
    float luminance_limit = peakLuminance / ref_luminance;

    for (int testIndex = 0; testIndex < test_count; testIndex = testIndex + 1) {
        // Compute gamut boundary intersection
        float approxLimit_M = find_gamut_boundary_intersection(JMcusp,
                                                               limit_J_max,
                                                               top_gamma_inv,
                                                               lower_hull_gamma_inv,
                                                               J_intersect_source[testIndex],
                                                               slopes[testIndex],
                                                               J_intersect_cusp[testIndex]);
        float approxLimit_J = J_intersect_source[testIndex] + slopes[testIndex] * approxLimit_M;

        // Store JMh values
        float approximate_JMh[3] = {approxLimit_J, approxLimit_M, test_JMh[testIndex][2]};

        // Convert to RGB
        float newLimitRGB[3];
        JMh_to_RGB(newLimitRGB, approximate_JMh, limit_params);

        // Check if any values exceed the luminance limit. If so, we are outside of the top gamut shell.
        if (!outside_hull(newLimitRGB, luminance_limit))
            return false;
    }

    return true;
}

__DEVICE__ void make_upper_hull_gamma_table(float upper_hull_gamma[totalTableSize], float gamutCuspTable[totalTableSize][3], ODTParams p) {
    // Find upper hull gamma values for the gamut mapper.
    // Start by taking a h angle
    // Get the cusp J value for that angle
    // Find a J value halfway to the Jmax
    // Iterate through gamma values until the approximate max M is
    // negative through the actual boundary

    // positions between the cusp and Jmax we will check variables that get
    // set as we iterate through, once all are set to true we break the loop

    for (int i = baseIndex; i != baseIndex + tableSize; i = i + 1) {
        // Get cusp from cusp table at hue position
        float hue = gamutCuspTable[i][2];
        float JMcusp[2] = {gamutCuspTable[i][0], gamutCuspTable[i][1]};

        float test_JMh[test_count][3];
        float J_intersect_source[test_count];
        float slopes[test_count];
        float J_intersect_cusp[test_count];

        generate_gamma_test_data(JMcusp, hue, p.limit_J_max, p.mid_J, p.focus_dist, test_JMh, J_intersect_source, slopes, J_intersect_cusp);

        float search_range = gamma_search_step;
        float low = gamma_minimum;
        float high = low + search_range;
        bool outside = false;
        while (!(outside) && (high < gamma_maximum)) {
            bool gammaFound = evaluate_gamma_fit(JMcusp,
                                                 test_JMh,
                                                 J_intersect_source,
                                                 slopes,
                                                 J_intersect_cusp,
                                                 1.f / high,
                                                 p.peakLuminance,
                                                 p.limit_J_max,
                                                 p.lower_hull_gamma_inv,
                                                 p.limit_params);
            if (!gammaFound) {
                low = high;
                high = high + search_range;
            } else {
                outside = true;
            }
        }

        float testGamma = -1.0f;
        while ((high - low) > gamma_accuracy) {
            testGamma = midpoint(high, low);
            bool gammaFound = evaluate_gamma_fit(JMcusp,
                                                 test_JMh,
                                                 J_intersect_source,
                                                 slopes,
                                                 J_intersect_cusp,
                                                 1.f / testGamma,
                                                 p.peakLuminance,
                                                 p.limit_J_max,
                                                 p.lower_hull_gamma_inv,
                                                 p.limit_params);
            if (gammaFound) {
                high = testGamma;
            } else {
                low = testGamma;
            }
        }

        upper_hull_gamma[i] = 1.f / high;
    }

    // Copy last populated entry to first empty spot
    upper_hull_gamma[0] = upper_hull_gamma[tableSize];

    // Copy first populated entry to last empty spot
    upper_hull_gamma[tableSize + baseIndex] = upper_hull_gamma[baseIndex];
}

__DEVICE__ int hue_position_in_uniform_table(float hue, int table_size) {
    const float wrapped_hue = wrap_to_360(hue);
    int result = (wrapped_hue / hue_limit * table_size);
    return result;
}

__DEVICE__ void determine_hue_linearity_search_range(int hue_linearity_search_range[2], float hue_table[totalTableSize]) {
    // This function searches through the hues looking for the largest
    // deviations from a linear distribution. We can then use this to initialise
    // the binary search range to something smaller than the full one to reduce
    // the number of lookups per hue lookup from ~ceil(log2(table size)) to
    // ~ceil(log2(range)) during image rendering.

    const int lower_padding = 0;
    const int upper_padding = 1;

    hue_linearity_search_range[0] = lower_padding;
    hue_linearity_search_range[1] = upper_padding;

    for (int i = baseIndex; i != baseIndex + tableSize; i = i + 1) {
        const int pos = hue_position_in_uniform_table(hue_table[i], totalTableSize);
        const int delta = i - pos;
        hue_linearity_search_range[0] = _fminf(hue_linearity_search_range[0], (float)delta + lower_padding);
        hue_linearity_search_range[1] = _fmaxf(hue_linearity_search_range[1], (float)delta + upper_padding);
    }
}

__DEVICE__ ODTParams init_ODTParams(float peakLuminance, Chromaticities limitingPrimaries) {
    ODTParams p;

    p.peakLuminance = peakLuminance;

    // JMh parameters
    p.input_params = init_JMhParams(AP0);
    p.reach_params = init_JMhParams(REACH_PRI);
    p.limit_params = init_JMhParams(limitingPrimaries);

    // Tonescale parameters
    p.ts = init_TSParams(peakLuminance);

    // Shared compression paramters
    p.limit_J_max = Y_to_J(peakLuminance, p.input_params);
    const float model_gamma = surround[1] * (1.48f + _sqrtf(Y_b / ref_luminance));
    p.model_gamma_inv = 1.f / model_gamma;
    make_reach_m_table(p.TABLE_reach_M, p.reach_params, p.limit_J_max);

    // Chroma compression parameters
    p.sat = _fmaxf(0.2f, chroma_expand - (chroma_expand * chroma_expand_fact) * p.ts.log_peak);
    p.sat_thr = chroma_expand_thr / peakLuminance;
    p.compr = chroma_compress + (chroma_compress * chroma_compress_fact) * p.ts.log_peak;
    p.chroma_compress_scale = powf(0.03379f * peakLuminance, 0.30596f) - 0.45135f;

    // Gamut compression parameters
    p.mid_J = Y_to_J(p.ts.c_t * ref_luminance, p.input_params);
    p.focus_dist = focus_distance + focus_distance * focus_distance_scaling * p.ts.log_peak;
    const float lower_hull_gamma = 1.14f + 0.07f * p.ts.log_peak;
    p.lower_hull_gamma_inv = 1.f / lower_hull_gamma;
    make_uniform_hue_gamut_table(p.TABLE_gamut_cusps, p.reach_params, p.limit_params, p);
    for (int i = 0; i != totalTableSize; i = i + 1) {
        p.TABLE_hues[i] = p.TABLE_gamut_cusps[i][2];
    }
    make_upper_hull_gamma_table(p.TABLE_upper_hull_gamma, p.TABLE_gamut_cusps, p);
    determine_hue_linearity_search_range(p.hue_linearity_search_range, p.TABLE_hues);

    return p;
}

__DEVICE__ void clamp_AP0_to_AP1(float AP0_clamped[3], float aces[3], float clamp_lower_limit, float clamp_upper_limit) {

    float AP0_XYZ_TO_RGB[3][3];
    XYZtoRGB_f33(AP0_XYZ_TO_RGB, AP0, 1.0f);
    float AP0_RGB_TO_XYZ[3][3];
    RGBtoXYZ_f33(AP0_RGB_TO_XYZ, AP0, 1.0f);

    float AP1_XYZ_TO_RGB[3][3];
    XYZtoRGB_f33(AP1_XYZ_TO_RGB, AP1, 1.0f);
    float AP1_RGB_TO_XYZ[3][3];
    RGBtoXYZ_f33(AP1_RGB_TO_XYZ, AP1, 1.0f);

    float AP0_TO_AP1[3][3];
    mm_33_33(AP0_TO_AP1, AP0_RGB_TO_XYZ, AP1_XYZ_TO_RGB);
    float AP1_TO_AP0[3][3];
    mm_33_33(AP1_TO_AP0, AP1_RGB_TO_XYZ, AP0_XYZ_TO_RGB);

    float AP1_vec[3];
    vm_3_33(AP1_vec, aces, AP0_TO_AP1);
    float AP1_clamped[3];
    clamp_f3(AP1_clamped, AP1_vec, clamp_lower_limit, clamp_upper_limit);

    vm_3_33(AP0_clamped, AP1_clamped, AP1_TO_AP0);
}

__DEVICE__ float _A_to_Y(float A, JMhParams p) {
    float Ra = p.A_w_J * A;
    float Y = _post_adaptation_cone_response_compression_inv(Ra) / p.F_L_n;

    return Y;
}

__DEVICE__ float J_to_Y(float J, JMhParams p) {
    float abs_J = _fabs(J);

    return _A_to_Y(J_to_Achromatic_n(abs_J, p.inv_cz), p);
}

/* --- Tone scale math --- */
__DEVICE__ float tonescale_fwd(float x,        // scene-referred input (i.e. linear ACES2065-1)
                               TSParams params // struct of type TSParams
) {
    // forward MM tone scale
    float f = params.m_2 * powf(_fmaxf(0.0f, x) / (x + params.s_2), params.g);
    float h = _fmaxf(0.f, f * f / (f + params.t_1)); // forward flare

    return h * params.n_r; // output is luminance in cd/m^2
}

__DEVICE__ float chroma_compress_norm(float h, float chroma_compress_scale) {
    float hr = degrees_to_radians(h);

    float a = _cosf(hr);
    float b = _sinf(hr);
    float cos_hr2 = a * a - b * b;
    float sin_hr2 = 2.0f * a * b;
    float cos_hr3 = 4.0f * a * a * a - 3.0f * a;
    float sin_hr3 = 3.0f * b - 4.0f * b * b * b;

    float M = 11.34072f * a + 16.46899f * cos_hr2 + 7.88380f * cos_hr3 + 14.66441f * b + -6.37224f * sin_hr2 + 9.19364f * sin_hr3 + 77.12896f;

    return M * chroma_compress_scale;
}

__DEVICE__ float reach_M_from_table(float h, float table[]) {
    int base = hue_position_in_uniform_table(h, tableSize);
    float t = h - base;
    int i_lo = base + baseIndex;
    int i_hi = i_lo + 1;

    return lerp(table[i_lo], table[i_hi], t);
}

// A "toe" function that remaps the given value x between 0 and limit.
// The k1 and k2 parameters change the size and shape of the toe.
// https://www.desmos.com/calculator/6vplvw14ti
__DEVICE__ float toe(float x, float limit, float k1_in, float k2_in, bool invert) {
    if (x > limit)
        return x;

    float k2 = _fmaxf(k2_in, 0.001f);
    float k1 = _sqrtf(k1_in * k1_in + k2 * k2);
    float k3 = (limit + k1) / (limit + k2);

    if (invert) {
        return (x * x + k1 * x) / (k3 * (x + k2));
    } else {
        const float minus_b = k3 * x - k1;
        const float minus_c = k2 * k3 * x;
        return 0.5f * (minus_b + _sqrtf(minus_b * minus_b + 4.f * minus_c));
    }
}

__DEVICE__ void chroma_compress_fwd(float out[3], float JMh[3], float tonemapped_J, ODTParams p, bool invert) {
    float J = JMh[0];
    float M = JMh[1];
    float h = JMh[2];

    float M_compr = M;

    if (M != 0.0f) {
        const float nJ = tonemapped_J / p.limit_J_max;
        const float snJ = _fmaxf(0.f, 1.f - nJ);
        float Mnorm = chroma_compress_norm(h, p.chroma_compress_scale);
        float limit = powf(nJ, p.model_gamma_inv) * reach_M_from_table(h, p.TABLE_reach_M) / Mnorm;

        float toe_limit = limit - 0.001f;
        float toe_snJ_sat = snJ * p.sat;
        float toe_sqrt_nJ_sat_thr = _sqrtf(nJ * nJ + p.sat_thr);
        float toe_nJ_compr = nJ * p.compr;

        // Rescaling of M with the tonescaled J to get the M to the same range as
        // J after the tonescale.  The rescaling uses the Hellwig2022 model gamma to
        // keep the M/J ratio correct (keeping the chromaticities constant).
        M_compr = M * powf(tonemapped_J / J, p.model_gamma_inv);

        // Normalize M with the rendering space cusp M
        M_compr = M_compr / Mnorm;

        // Expand the colorfulness by running the toe function in reverse.  The goal is to
        // expand less saturated colors less and more saturated colors more.  The expansion
        // increases saturation in the shadows and mid-tones but not in the highlights.
        // The 0.001 offset starts the expansions slightly above zero.  The sat_thr makes
        // the toe less aggressive near black to reduce the expansion of noise.
        M_compr = limit - toe(limit - M_compr, toe_limit, toe_snJ_sat, toe_sqrt_nJ_sat_thr, false);

        // Compress the colorfulness.  The goal is to compress less saturated colors more and
        // more saturated colors less, especially in the highlights.  This step creates the
        // saturation roll-off in the highlights, but attemps to preserve pure colors.  This
        // mostly affects highlights and mid-tones, and does not compress shadows.
        M_compr = toe(M_compr, limit, toe_nJ_compr, snJ, false);

        // Denormalize
        M_compr = M_compr * Mnorm;
    }

    out[0] = tonemapped_J;
    out[1] = M_compr;
    out[2] = h;
}

__DEVICE__ void tonemap_and_compress_fwd(float JMh_tc[3], float JMh[3], ODTParams p) {
    // Applies the forward tonescale, then compresses M based on J and tonemapped J

    // Tonemap
    float linear = J_to_Y(JMh[0], p.input_params) / ref_luminance;

    float tonemapped_Y = tonescale_fwd(linear, p.ts);

    float J_ts = Y_to_J(tonemapped_Y, p.input_params);

    // Compress M; function returns { tonemapped J, compressed M, h }
    chroma_compress_fwd(JMh_tc, JMh, J_ts, p, false);
}

__DEVICE__ int lookup_hue_interval(float h, float hue_table[totalTableSize], int hue_linearity_search_range[2]) {
    // Search the given table for the interval containing the desired hue
    // Returns the upper index of the interval

    // We can narrow the search range based on the hues being almost uniform
    unsigned int i = baseIndex + hue_position_in_uniform_table(h, totalTableSize);
    unsigned int i_lo = (unsigned int)_fmaxf((float)baseIndex, (float)i + hue_linearity_search_range[0]);
    unsigned int i_hi = (unsigned int)_fminf((float)baseIndex + tableSize, (float)i + hue_linearity_search_range[1]);

    while (i_lo + 1 < i_hi) {
        if (h > hue_table[i]) {
            i_lo = i;
        } else {
            i_hi = i;
        }
        i = midpoint(i_lo, i_hi);
    }

    i_hi = _fmaxf((float)1, (float)i_hi);

    return i_hi;
}

__DEVICE__ float interpolation_weight(float h, float h_lo, float h_hi) {
    return (h - h_lo);
}

__DEVICE__ void cusp_from_table(float cusp_JM[2], float h, float table[][3]) {
    float lo[3];
    float hi[3];

    int low_i = 0;
    int high_i = baseIndex + tableSize;
    int i = hue_position_in_uniform_table(h, tableSize) + baseIndex;

    while (low_i + 1 < high_i) {
        if (h > table[i][2]) {
            low_i = i;
        } else {
            high_i = i;
        }
        i = midpoint(low_i, high_i);
    }
    copy_f3(lo, table[high_i - 1]);
    copy_f3(hi, table[high_i]);

    float t = (h - lo[2]) / (hi[2] - lo[2]);
    float cusp_J = lerp(lo[0], hi[0], t);
    float cusp_M = lerp(lo[1], hi[1], t);

    cusp_JM[0] = cusp_J;
    cusp_JM[1] = cusp_M;
}

__DEVICE__ HueDependentGamutParams init_HueDependentGamutParams(float hue, ODTParams p) {
    HueDependentGamutParams hdp;
    hdp.gamma_bottom_inv = p.lower_hull_gamma_inv;

    const int i_hi = lookup_hue_interval(hue, p.TABLE_hues, p.hue_linearity_search_range);
    const float t = interpolation_weight(hue, p.TABLE_hues[i_hi - 1], p.TABLE_hues[i_hi]);

    cusp_from_table(hdp.JMcusp, hue, p.TABLE_gamut_cusps);
    hdp.gamma_top_inv = lerp(p.TABLE_upper_hull_gamma[i_hi - 1], p.TABLE_upper_hull_gamma[i_hi], t);
    hdp.focus_J = compute_focus_J(hdp.JMcusp[0], p.mid_J, p.limit_J_max);
    hdp.analytical_threshold = lerp(hdp.JMcusp[0], p.limit_J_max, focus_gain_blend);

    return hdp;
}

__DEVICE__ float reinhard_remap(float scale, float nd, bool invert) {
    if (invert) {
        if (nd >= 1.0f) {
            return scale;
        } else {
            return scale * -(nd / (nd - 1.f));
        }
    }
    return scale * nd / (1.f + nd);
}

__DEVICE__ float remap_M(float M, float gamut_boundary_M, float reach_boundary_M, bool invert) {
    const float boundary_ratio = gamut_boundary_M / reach_boundary_M;
    const float proportion = _fmaxf(boundary_ratio, compression_threshold);
    const float threshold = proportion * gamut_boundary_M;

    if (M <= threshold || proportion >= 1.f)
        return M;

    // Translate to place threshold at zero
    const float m_offset = M - threshold;
    const float gamut_offset = gamut_boundary_M - threshold;
    const float reach_offset = reach_boundary_M - threshold;

    const float scale = reach_offset / ((reach_offset / gamut_offset) - 1.f);
    const float nd = m_offset / scale;

    // Shift result back to absolute
    return threshold + reinhard_remap(scale, nd, invert);
}

__DEVICE__ void compress_gamut(float JMhcompressed[3], float JMh[3], float Jx, ODTParams p, HueDependentGamutParams hdp, bool invert) {
    const float J = JMh[0];
    const float M = JMh[1];
    const float h = JMh[2];

    const float slope_gain = get_focus_gain(Jx, hdp.analytical_threshold, p.limit_J_max, p.focus_dist);
    const float J_intersect_source = solve_J_intersect(J, M, hdp.focus_J, p.limit_J_max, slope_gain);
    const float gamut_slope = compute_compression_vector_slope(J_intersect_source, hdp.focus_J, p.limit_J_max, slope_gain);

    const float J_intersect_cusp = solve_J_intersect(hdp.JMcusp[0], hdp.JMcusp[1], hdp.focus_J, p.limit_J_max, slope_gain);

    const float gamut_boundary_M = find_gamut_boundary_intersection(
        hdp.JMcusp, p.limit_J_max, hdp.gamma_top_inv, hdp.gamma_bottom_inv, J_intersect_source, gamut_slope, J_intersect_cusp);

    if (gamut_boundary_M <= 0.f) {
        float returnJMh[3] = {J, 0.f, h};
        copy_f3(JMhcompressed, returnJMh);
        return;
    }

    float reach_max_M = reach_M_from_table(h, p.TABLE_reach_M);

    const float reach_boundary_M = estimate_line_and_boundary_intersection_M(
        J_intersect_source, gamut_slope, p.model_gamma_inv, p.limit_J_max, reach_max_M, p.limit_J_max);

    const float remapped_M = remap_M(M, gamut_boundary_M, reach_boundary_M, invert);

    JMhcompressed[0] = J_intersect_source + remapped_M * gamut_slope;
    JMhcompressed[1] = remapped_M;
    JMhcompressed[2] = h;
}

__DEVICE__ void gamut_compress_fwd(float out[3], float JMh[3], ODTParams p) {
    const float J = JMh[0];
    const float M = JMh[1];
    const float h = JMh[2];

    if (J <= 0.0f) {
        float JMh[3] = {0.f, 0.f, h};
        copy_f3(out, JMh);
        return;
    }

    if (M < 0.f || J > p.limit_J_max) {
        float JMh[3] = {J, 0.f, h};
        copy_f3(out, JMh);
        return;
    }

    HueDependentGamutParams hdp = init_HueDependentGamutParams(h, p);

    compress_gamut(out, JMh, J, p, hdp, false);
}

__DEVICE__ void outputTransform_fwd(float RGBout[3], float aces[3], ODTParams p) {
    float AP0_clamped[3];
    clamp_AP0_to_AP1(AP0_clamped, aces, 0.f, p.ts.forward_limit);

    float JMh[3];
    RGB_to_JMh(JMh, AP0_clamped, p.input_params);

    float tonemappedJMh[3];
    tonemap_and_compress_fwd(tonemappedJMh, JMh, p);

    float compressedJMh[3];
    gamut_compress_fwd(compressedJMh, tonemappedJMh, p);

    JMh_to_RGB(RGBout, compressedJMh, p.limit_params);
}

// White point scaling
//     If the creative white differs from the calibration white of the display,
//     unequal display code values will be required to produce the neutral of
//     the creative white. Without scaling, one channel would hit the max value
//     first while the other channels continue to increase, resulting in a hue
//     shift. To avoid this, the white scaling finds the largest channel and
//     applies a scale factor to force the point where this channel hits max to
//     1.0, assuring that all three channels "fit" within the peak value. In the
//     inverse direction, the white scaling is removed.
__DEVICE__ void apply_white_scale(float out[3], float rgb[3], float MAT_limit_to_display[3][3], bool invert) {
    float RGB_w_f[3];
    float one_vec[3] = {1.0f, 1.0f, 1.0f};
    vm_3_33(RGB_w_f, one_vec, MAT_limit_to_display);
    float scale = 1.f / _fmaxf(_fmaxf(RGB_w_f[0], RGB_w_f[1]), RGB_w_f[2]);
    // scale factor is equal to 1/largestChannel

    if (invert) {
        float rgb_temp[3];
        fv_f_f3(rgb_temp, 1.f / scale, rgb);
        clamp_f3(out, rgb_temp, 0, 1);
    } else {
        fv_f_f3(out, scale, rgb);
    }
}

// Converts from linear cd/m^2 to the non-linear perceptually quantized space
// Note that this is in float, and assumes normalization from 0 - 1
// (0 - pq_C for linear) and does not handle the integer coding in the Annex
// sections of SMPTE ST 2084-2014
__DEVICE__ float Y_to_ST2084(float C) {
    // Constants from SMPTE ST 2084-2014
    const float pq_m1 = 0.1593017578125f; // ( 2610.0f / 4096.0f ) / 4.0f;
    const float pq_m2 = 78.84375f;        // ( 2523.0f / 4096.0f ) * 128.0f;
    const float pq_c1 = 0.8359375f;       // 3424.0f / 4096.0f or pq_c3 - pq_c2 + 1.0f;
    const float pq_c2 = 18.8515625f;      // ( 2413.0f / 4096.0f ) * 32.0f;
    const float pq_c3 = 18.6875f;         // ( 2392.0f / 4096.0f ) * 32.0f;

    const float pq_C = 10000.0f;
    // Note that this does NOT handle any of the signal range
    // considerations from 2084 - this returns full range (0 - 1)
    float L = C / pq_C;
    float Lm = powf(L, pq_m1);
    float N = (pq_c1 + pq_c2 * Lm) / (1.0f + pq_c3 * Lm);
    N = powf(N, pq_m2);
    return N;
}

// Converts from the non-linear perceptually quantized space to linear cd/m^2
// Note that this is in float, and assumes normalization from 0 - 1
// (0 - pq_C for linear) and does not handle the integer coding in the Annex
// sections of SMPTE ST 2084-2014
__DEVICE__ float ST2084_to_Y(float N) {
    // Constants from SMPTE ST 2084-2014
    const float pq_m1 = 0.1593017578125f; // ( 2610.0f / 4096.0f ) / 4.0f;
    const float pq_m2 = 78.84375f;        // ( 2523.0f / 4096.0f ) * 128.0f;
    const float pq_c1 = 0.8359375f;       // 3424.0f / 4096.0f or pq_c3 - pq_c2 + 1.0f;
    const float pq_c2 = 18.8515625f;      // ( 2413.0f / 4096.0f ) * 32.0f;
    const float pq_c3 = 18.6875f;         // ( 2392.0f / 4096.0f ) * 32.0f;

    const float pq_C = 10000.0f;
    // Note that this does NOT handle any of the signal range
    // considerations from 2084 - this assumes full range (0 - 1)
    float Np = powf(N, 1.0f / pq_m2);
    float L = Np - pq_c1;
    if (L < 0.0f)
        L = 0.0f;
    L = L / (pq_c2 - pq_c3 * Np);
    L = powf(L, 1.0f / pq_m1);
    return L * pq_C; // returns cd/m^2
}

// converts from linear cd/m^2 to PQ code values
__DEVICE__ void Y_to_ST2084_f3(float out[3], float in[3]) {
    out[0] = Y_to_ST2084(in[0]);
    out[1] = Y_to_ST2084(in[1]);
    out[2] = Y_to_ST2084(in[2]);
}

// converts from PQ code values to linear cd/m^2
__DEVICE__ void ST2084_to_Y_f3(float out[3], float in[3]) {
    out[0] = ST2084_to_Y(in[0]);
    out[1] = ST2084_to_Y(in[1]);
    out[2] = ST2084_to_Y(in[2]);
}

// Conversion of PQ signal to HLG, as detailed in Section 7 of ITU-R BT.2390-0
__DEVICE__ void ST2084_to_HLG_1000nits_f3(float HLG[3], float PQ[3]) {
    // ST.2084 EOTF (non-linear PQ to display light)
    float displayLinear[3];
    ST2084_to_Y_f3(displayLinear, PQ);

    // HLG Inverse EOTF (i.e. HLG inverse OOTF followed by the HLG OETF)
    // HLG Inverse OOTF (display linear to scene linear)
    float Y_d = 0.2627f * displayLinear[0] + 0.6780f * displayLinear[1] + 0.0593f * displayLinear[2];
    const float L_w = 1000.f;
    const float L_b = 0.f;
    const float alpha = (L_w - L_b);
    const float beta = L_b;
    const float gamma = 1.2f;

    float sceneLinear[3];
    if (Y_d == 0.f) {
        /* This case is to protect against pow(0,-N)=Inf error. The ITU document
        does not offer a recommendation for this corner case. There may be a
        better way to handle this, but for now, this works.
        */
        sceneLinear[0] = 0.f;
        sceneLinear[1] = 0.f;
        sceneLinear[2] = 0.f;
    } else {
        sceneLinear[0] = powf((Y_d - beta) / alpha, (1.f - gamma) / gamma) * ((displayLinear[0] - beta) / alpha);
        sceneLinear[1] = powf((Y_d - beta) / alpha, (1.f - gamma) / gamma) * ((displayLinear[1] - beta) / alpha);
        sceneLinear[2] = powf((Y_d - beta) / alpha, (1.f - gamma) / gamma) * ((displayLinear[2] - beta) / alpha);
    }

    // HLG OETF (scene linear to non-linear signal value)
    const float a = 0.17883277f;
    const float b = 0.28466892f; // 1.f-4.f*a;
    const float c = 0.55991073f; // 0.5f-a*log(4.f*a);

    if (sceneLinear[0] <= 1.f / 12) {
        HLG[0] = _sqrtf(3.f * sceneLinear[0]);
    } else {
        HLG[0] = a * _logf(12.f * sceneLinear[0] - b) + c;
    }
    if (sceneLinear[1] <= 1.f / 12) {
        HLG[1] = _sqrtf(3.f * sceneLinear[1]);
    } else {
        HLG[1] = a * _logf(12.f * sceneLinear[1] - b) + c;
    }
    if (sceneLinear[2] <= 1.f / 12) {
        HLG[2] = _sqrtf(3.f * sceneLinear[2]);
    } else {
        HLG[2] = a * _logf(12.f * sceneLinear[2] - b) + c;
    }
}

// The reverse EOTF specified in Rec. ITU-R BT.1886
// L = a(max[(V+b),0])^g
__DEVICE__ float bt1886_inv(float L, float gamma, float Lw, float Lb) {
    float a = powf(powf(Lw, 1.f / gamma) - powf(Lb, 1.f / gamma), gamma);
    float b = powf(Lb, 1.f / gamma) / (powf(Lw, 1.f / gamma) - powf(Lb, 1.f / gamma));
    float V = powf(_fmaxf(L / a, 0.f), 1.f / gamma) - b;
    return V;
}

__DEVICE__ void bt1886_inv_f3(float V[3], float L[3], float gamma, float Lw, float Lb) {
    V[0] = bt1886_inv(L[0], gamma, Lw, Lb);
    V[1] = bt1886_inv(L[1], gamma, Lw, Lb);
    V[2] = bt1886_inv(L[2], gamma, Lw, Lb);
}

__DEVICE__ float moncurve_inv(float y, float gamma, float offs) {
    float x;
    const float yb = powf(offs * gamma / ((gamma - 1.0f) * (1.0f + offs)), gamma);
    const float rs = powf((gamma - 1.0f) / offs, gamma - 1.0f) * powf((1.0f + offs) / gamma, gamma);
    if (y >= yb) {
        x = (1.0f + offs) * powf(y, 1.0f / gamma) - offs;
    } else {
        x = y * rs;
    }
    return x;
}

__DEVICE__ void moncurve_inv_f3(float x[3], float y[3], float gamma, float offs) {
    x[0] = moncurve_inv(y[0], gamma, offs);
    x[1] = moncurve_inv(y[1], gamma, offs);
    x[2] = moncurve_inv(y[2], gamma, offs);
}

__DEVICE__ void eotf_inv(float cv[3], float rgb_linear_in[3], int eotf_enum) {
    // Extra clamp of negatives protect against edge case negative values. Data
    // is clamped from 0-peakLuminance in the white limiting step but sometimes
    // a very small negative value can be reintroduced from precision errors.
    float rgb_linear[3];
    rgb_linear[0] = _fmaxf(0.0f, rgb_linear_in[0]);
    rgb_linear[1] = _fmaxf(0.0f, rgb_linear_in[1]);
    rgb_linear[2] = _fmaxf(0.0f, rgb_linear_in[2]);

    if (eotf_enum == 0) {
        // display linear
        copy_f3(cv, rgb_linear);
    } else if (eotf_enum == 1) {
        // ST. 2084
        float rgb_scaled[3];
        fv_f_f3(rgb_scaled, ref_luminance, rgb_linear);
        Y_to_ST2084_f3(cv, rgb_scaled);
    } else if (eotf_enum == 2) {
        // HLG
        float rgb_scaled[3];
        fv_f_f3(rgb_scaled, ref_luminance, rgb_linear);
        float PQ[3];
        Y_to_ST2084_f3(PQ, rgb_scaled);
        ST2084_to_HLG_1000nits_f3(cv, PQ);
    } else if (eotf_enum == 3) {
        // gamma 2.6
        powf3(cv, rgb_linear, 1 / 2.6f);
    } else if (eotf_enum == 4) {
        // BT.1886 with gamma 2.4
        bt1886_inv_f3(cv, rgb_linear, 2.4f, 1.0f, 0.0f);
    } else if (eotf_enum == 5) {
        // gamma 2.2
        powf3(cv, rgb_linear, 1 / 2.2f);
    } else {
        // sRGB IEC 61966-2-1:1999
        moncurve_inv_f3(cv, rgb_linear, 2.4f, 0.055f);
    }
}

__DEVICE__ void display_encoding(float cv[3], float rgb[3], float MAT_limit_to_display[3][3], int eotf_enum, float linear_scale) {
    // Limiting to display primary encoding
    float rgb_display_linear[3];
    vm_3_33(rgb_display_linear, rgb, MAT_limit_to_display);

    // Linear scale factor
    float rgb_display_scaled[3];
    fv_f_f3(rgb_display_scaled, linear_scale, rgb_display_linear);

    // Apply inverse EOTF
    eotf_inv(cv, rgb_display_scaled, eotf_enum);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // ---- ODT PARAMETERS BELOW ---- //

    // Rendering intent
    // Chromaticities of limiting primaries and white point
    const Chromaticities limitingPri = // P3 Primaries / D65 White
        {
            {0.6800f, 0.3200f},
            {0.2650f, 0.6900f},
            {0.1500f, 0.0600f},
            {0.3127f, 0.3290f},
        };

    const float peakLuminance = 1000.f; // luminance the tone scale highlight rolloff will target in cd/m^2 (nits)
    const bool scale_white = false;    // apply scaling to compress output so that largest channel hits 1.0f; usually enabled when using a
                                       // limiting white different from the encoding white

    // Encoding
    // Chromaticities of display primaries and white point
    const Chromaticities encodingPri = // P3 Primaries / D65 White
        {
            {0.6800f, 0.3200f},
            {0.2650f, 0.6900f},
            {0.1500f, 0.0600f},
            {0.3127f, 0.3290f},
        };

    // EOTF of display (output is encoded with the inverse EOTF)
    //  0 - display linear
    //  1 - ST.2084
    //  2 - HLG
    //  3 - gamma 2.6
    //  4 - BT.1886 with gamma 2.4
    //  5 - gamma 2.2
    //  6 - sRGB IEC 61966-2-1:1999
    const int eotf_enum = 1;

    // ---- ---- ---- ---- ---- ---- //

    const float linear_scale_factor = 1.0f;

    // Initialization functions
    // These only need to be calculated once and are done here at the global level to assure they are not done per pixel.

    // Calculate parameters derived from luminance and primaries
    const ODTParams ODT_PARAMS = init_ODTParams(peakLuminance, limitingPri);

    float MATRIX_limit_to_display[3][3];
    float rgb_to_xyz[3][3];
    RGBtoXYZ_f33(rgb_to_xyz, limitingPri, 1.0f);
    float xyz_to_rgb[3][3];
    XYZtoRGB_f33(xyz_to_rgb, encodingPri, 1.0f);
    mm_33_33(MATRIX_limit_to_display, rgb_to_xyz, xyz_to_rgb);

    // ---- ---- ---- ---- ---- ---- //
    // TRANSFORM LOGIC
    // ---- ---- ---- ---- ---- ---- //

    // ---- Assemble Input ---- //
    float aces[3] = {p_R, p_G, p_B};

    // ---- Output Transform ---- //
    float rgb[3];
    outputTransform_fwd(rgb, aces, ODT_PARAMS);

    // ---- Clamp to peak luminance ---- //
    float rgb2[3];
    clamp_f3(rgb2, rgb, 0.0f, peakLuminance / ref_luminance);

    // ---- Scale white, needed if limiting white != encoding white ----
    float rgb3[3];
    if (scale_white) {
        apply_white_scale(rgb3, rgb2, MATRIX_limit_to_display, false);
    } else {
        copy_f3(rgb3, rgb2);
    }

    // ---- Display Encoding ---- //
    float cv[3];
    display_encoding(cv, rgb3, MATRIX_limit_to_display, eotf_enum, linear_scale_factor);

    float3 output = make_float3(cv[0], cv[1], cv[2]);
    return output;
}
