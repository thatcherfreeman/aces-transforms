// Written by Thatcher Freeman
// Based on official documentation.
// clang-format off
DEFINE_ACES_PARAM(IS_PARAMETRIC_ACES_TRANSFORM: 0)
// clang-format on

__DEVICE__ float linear_to_phantom_log1(float x) {
    const float a = 0.182f;
    const float b = 30.0f;
    const float c = 0.011375f;
    const float d = 0.0f;
    const float e = 0.377675f;
    const float s = 16.0f;

    float out;
    if (x < c) {
        out = s * x;
    } else {
        out = a * _logf(b * x + d) + e;
    }
    return out;
}

__DEVICE__ float3 mv_33_3(float mat[3][3], float3 v) {
    float3 out = make_float3(mat[0][0] * v.x + mat[0][1] * v.y + mat[0][2] * v.z,
                             mat[1][0] * v.x + mat[1][1] * v.y + mat[1][2] * v.z,
                             mat[2][0] * v.x + mat[2][1] * v.y + mat[2][2] * v.z);
    return out;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 rgb = make_float3(p_R, p_G, p_B);

    // Used inverse of the matrix in the IDT.
    float matrix[3][3] = {
        {2.5219347298f, -1.1370238965f, -0.3849108336f},
        {-0.2754794279f, 1.3698289786f, -0.0943495507f},
        {-0.0159828700f, -0.1477892341f, 1.1637721042f},
    };
    float3 rgb2 = mv_33_3(matrix, rgb);

    const float gain = _exp2f(1.55f);
    rgb2 = rgb2 / gain;

    float3 out = make_float3(linear_to_phantom_log1(rgb2.x), linear_to_phantom_log1(rgb2.y), linear_to_phantom_log1(rgb2.z));
    return out;
}
